04 - Data de Publicação e Converters

01 - Adicionando a Data de Publicação

- Adicionar campo data no model do livro, mapeado para JPA para mostrar somentea  data.
@Entity
public class Livro {
///outros
	@Temporal(TemporalType.DATE)
	private Calendar dataPublicacao = Calendar.getInstance();
//outros 
	public Calendar getDataPublicacao() {
		return dataPublicacao;
	}
	public void setDataPublicacao(Calendar dataPublicacao) {
		this.dataPublicacao = dataPublicacao;
	}
- Adicionar campo na viewer mostrando mensagem de validação, converter para o dd/mm/yyy e buscando o ".time" final informa que usaremos um java.util.Date, pois nosso conversor f:convertDateTime só trabalha com Date.

<div>
	<h:outputLabel value="Data de Publicação" />
	<h:inputText 
			value="#{adminLivrosBean.livro.dataPublicacao.time}"
	        id="dataPublicacao">
	    	<f:convertDateTime pattern="dd/MM/yyyy"/>
	</h:inputText>
	<h:message for="dataPublicacao" />
</div>


02 - Guardando a data de publicação do Livro
Implmentado anteriormente.

03 - Cadastrando a data de publicação
Já implmentado

04 - Criando nosso próprio Converter

Criando classe para converter a data calender para o padrão e timzone desejado, sem tratar isso na viwer.

- Criar classe para converter a data de string que vem da viwer e objeto quando vem do manager bean.


05 - Criando um conversor para nossa data

@FacesConverter(forClass=Calendar.class) // converte da viwer para o mannageBean.
public class CalendarConverter implements Converter{
	
	private DateTimeConverter converter = new DateTimeConverter(); //objeto do Faces que trata conversão de data.

	public CalendarConverter() {
		converter.setPattern("dd/MM/yyyy"); // seta com o formatado desejado
		converter.setTimeZone(TimeZone.getTimeZone("America/Sao_Paulo")); // seta timezone da região.
	}

	@Override
	public Object getAsObject(FacesContext context, UIComponent component, String dataTexto) {

		Calendar calendar = Calendar.getInstance(); // instancia uma classe calender.
		
		Date data = (Date) converter.getAsObject(context, component, dataTexto); // converte de texto para Date, date é o padrão do JSF.
        calendar.setTime(data); // converte de Date para Calender, tipo do campo da classe livro.
		return calendar;
	}

	@Override
	public String getAsString(FacesContext context, UIComponent component, Object dataObject) {
		
		if(dataObject == null)
			return null;
		
		Calendar calendar = (Calendar) dataObject; // converte para Calender
		return converter.getAsString(context, component, calendar.getTime()); // Date do Calender converte para texto, já com os sets do construtor.
	}
}

- Retirado as tags da vier de tratamento de data, ficando o código mais limpo

<div>
	<h:outputLabel value="Data de Publicação" />
	<h:inputText value="#{adminLivrosBean.livro.dataPublicacao}"
	        id="dataPublicacao" />
	<h:message for="dataPublicacao" />	
</div>



06 - Convertendo datas

Porque tivemos que criar um conversor para Calendar se já existe um para Date?

Porque o conversor de Date trata apenas do tipo java.util.Date e queremos usar o tipo java.util.Calendar por ser mais novo e possuir mais recursos de manipulação de datas. Com um conversor próprio de Calendar evitamos fazer parse em todo local do sistema, tornando o código mais limpo e conciso.

07 - Convertendo o Autor

Criar um conversor string para o objeto autor, assim como foi feito com a data de string para o objeto data.

08 - Criando o conversor para Autor

- Criar classe conversora

@FacesConverter("autorConverter") // IDENTIFICAÇÃO PARA USAR NA VIWER JSF.
public class AutorConverter implements Converter{	
	private Autor autor = new Autor(); // INSTANCIA AUTOR().
	@Override
	public Object getAsObject(FacesContext context, UIComponent component, String id) {		
		if(id == null || id.trim().isEmpty()) return null; // VAZIO RETORNA NULL
		autor.setId(Integer.valueOf(id)); // RETORNA OBJETO COM O ID ESCOLHIDO NA VIEWER.		
		return autor;
	}

	@Override
	public String getAsString(FacesContext context, UIComponent component, Object autorObect) {		
		if(autorObect == null) return null;		
		autor = (Autor) autorObect;		
		return autor.getId().toString(); //RETORNA STRING CONFORME AUTOR PASSADO POR PARÂMETRO
	}
}

- Criar hashcode e equals na classe Autor, para ser utilizado pelo conversor, na hora da convesão.
@Override
public int hashCode() {
	final int prime = 31;
	int result = 1;
	result = prime * result + ((id == null) ? 0 : id.hashCode());
	return result;
}

@Override
public boolean equals(Object obj) {
	if (this == obj)
		return true;
	if (obj == null)
		return false;
	if (getClass() != obj.getClass())
		return false;
	Autor other = (Autor) obj;
	if (id == null) {
		if (other.id != null)
			return false;
	} else if (!id.equals(other.id))
		return false;
	return true;
}

- Altera a JSP para utilziar o conversor criado e não mais utiilizar id e sim o objeto autor.

<div>
<h:outputLabel value="Autores"/> //NOME DO CAMPO EXIBIDO NA TELA
<h:selectManyListbox             // TIPO DO CAMPO
	value="#{adminLivrosBean.livro.autores}" // RECEBE LISTA AUTORES SELECIONADO.
	converter="autorConverter" id="autores">  // CONVERSOR UTILZADO.
	<f:selectItems value="#{adminLivrosBean.autores}" // ITERA SOBRE UMA LISTA DE AUTORES VINDA DO MANAGERBEAN.
	               var="autor"   //RESEBE CADA AUTOR DA ITERAÇÃO
	               itemLabel="#{autor.nome}"/> //MOSTRA NOME DO AUTOR.
</h:selectManyListbox>
</div>



09 - Analisando o Converter de Autor

O que ganhamos criando o converter de Autor? (Selecione todas as opções aplicáveis)

Ganhamos flexibilidade na tela, fazendo com que componentes conheçam direto o objeto Autor, também mais semântica, uma vez que nosso sistema trabalha diretamente com objetos Autor e não mais com inteiros e temos um converter próprio, que já preenche a lista com instâncias de objetos Autor, colocando o ID do Autor selecionado no objeto. Assim, temos uma aplicação mais esperta e não temos que tratar listas de Integers.











